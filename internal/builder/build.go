package builder

import (
	"fmt"
	"html/template"
	"io"
	"net/url"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"time"

	"github.com/ufukty/kask/cmd/kask/commands/version"
	"github.com/ufukty/kask/internal/builder/bundle"
	"github.com/ufukty/kask/internal/builder/copy"
	"github.com/ufukty/kask/internal/builder/directory"
	"github.com/ufukty/kask/internal/builder/markdown"
)

var fileheader = fmt.Sprintf("<!-- Do not edit. Auto-generated by Kask %s -->", version.Version)

type Args struct {
	Src, Dst string
	Domain   string
	Dev      bool // suffixes css bundles with unique ids to bypass browser caching
	Verbose  bool
}

type pageref struct {
	dir  *dir2
	page string
}

type builder struct {
	args Args

	start time.Time

	assets        []string                  // src paths
	pagesMarkdown map[string]*markdown.Page // src path -> content
	leaves        map[pageref]*Node         // to access nodes built for sitemap beforehand
	links         map[string]string         // src path -> dst href (with stripped orderings)

	root3 *Node // for testing
}

func has[K comparable, V any](m map[K]V, k K) bool {
	_, ok := m[k]
	return ok
}

func (b *builder) checkCompetingEntries(dir *directory.Dir) error {
	children := map[string]int{}
	for _, subdir := range dir.Subdirs {
		children[subdir.Name] = 1
	}
	for _, page := range dir.PagesTmpl {
		if has(children, page) {
			children[page] = -1
		}
		children[page]++
	}
	for _, page := range dir.PagesMarkdown {
		if has(children, page) {
			children[page] = -1
		}
		children[page]++
	}
	duplicates := []string{}
	for child, freq := range children {
		if freq > 1 {
			duplicates = append(duplicates, child)
		}
	}
	if len(duplicates) > 0 {
		return fmt.Errorf("multiple entries sharing the same path for those: %s", strings.Join(duplicates, ", "))
	}
	for _, sub := range dir.Subdirs {
		if err := b.checkCompetingEntries(sub); err != nil {
			return fmt.Errorf("%q: %w", sub.Name, err)
		}
	}
	return nil
}

// used in assigning destination addresses, bundling css, and propagating tmpl files
type dir2 struct {
	Kask *directory.Kask
	Meta *directory.Meta

	SrcName, SrcPath, SrcAssets      string
	DstName, DstPath, DstPathEncoded string

	Subdirs []*dir2

	PagesMarkdown []string // src paths
	PagesTmpl     []string // src paths
	Stylesheets   []string // dst paths

	Tmpl *template.Template
}

func (b *builder) toDir2(d, p *directory.Dir, srcParent, dstParent, dstParentEncoded string) *dir2 {
	srcParent = filepath.Join(srcParent, d.Name)
	dstName := d.Name
	if !(p != nil && p.Meta != nil && p.Meta.PreserveOrdering) {
		dstName = stripOrdering(d.Name)
	}
	dstParent = filepath.Join(dstParent, dstName)
	dstParentEncoded = filepath.Join(dstParentEncoded, url.PathEscape(dstName))
	d2 := &dir2{
		Kask: d.Kask,
		Meta: d.Meta,

		Subdirs: []*dir2{},

		SrcName:   d.Name,
		SrcPath:   srcParent,
		SrcAssets: d.Assets,

		DstName:        dstName,
		DstPath:        dstParent,
		DstPathEncoded: dstParentEncoded,

		PagesMarkdown: d.PagesMarkdown,
		PagesTmpl:     d.PagesTmpl,
		Stylesheets:   nil,

		Tmpl: nil,
	}
	for _, subdir := range d.Subdirs {
		d2.Subdirs = append(d2.Subdirs, b.toDir2(subdir, d, srcParent, dstParent, dstParentEncoded))
	}
	return d2
}

func (b *builder) write(dst, content string) error {
	if b.args.Verbose {
		fmt.Println("writing", dst)
	}
	err := os.MkdirAll(filepath.Dir(dst), 0o755)
	if err != nil {
		return fmt.Errorf("creating directory: %w", err)
	}
	f, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("creating: %w", err)
	}
	defer f.Close()
	_, err = io.Copy(f, strings.NewReader(content))
	if err != nil {
		return fmt.Errorf("copying: %w", err)
	}
	return nil
}

func (b *builder) bundleAndPropagateStylesheets(d *dir2, toPropagate []string) error {
	d.Stylesheets = slices.Clone(toPropagate)

	if d.Kask != nil && d.Kask.Propagate != nil && len(d.Kask.Propagate.Css) > 0 {
		css, err := bundle.Files(d.Kask.Propagate.Css)
		if err != nil {
			return fmt.Errorf("bundling propagated css file: %w", err)
		}
		dst := "/" + filepath.Join(d.DstPath, "styles.propagate.css")
		if err := b.write(filepath.Join(b.args.Dst, dst), css); err != nil {
			return fmt.Errorf("writing propagated css file: %w", err)
		}
		d.Stylesheets = append(d.Stylesheets, dst)
		toPropagate = append(toPropagate, dst)
	}

	if d.Kask != nil && len(d.Kask.Css) > 0 {
		css, err := bundle.Files(d.Kask.Css)
		if err != nil {
			return fmt.Errorf("bundling at-level css file: %w", err)
		}
		dst := "/" + filepath.Join(d.DstPath, "styles.css")
		if err := b.write(filepath.Join(b.args.Dst, dst), css); err != nil {
			return fmt.Errorf("writing at-level css file: %w", err)
		}
		d.Stylesheets = append(d.Stylesheets, dst)
	}

	for _, subdir := range d.Subdirs {
		if err := b.bundleAndPropagateStylesheets(subdir, slices.Clone(toPropagate)); err != nil {
			return fmt.Errorf("%q: %w", subdir.SrcName, err)
		}
	}

	return nil
}

func (b *builder) propagateTemplates(d *dir2, toPropagate *template.Template) error {
	var err error

	if d.Kask != nil && d.Kask.Propagate != nil && len(d.Kask.Propagate.Tmpl) > 0 {
		toPropagate, err = toPropagate.ParseFiles(d.Kask.Propagate.Tmpl...)
		if err != nil {
			return fmt.Errorf("parsing to-propagate template files: %w", err)
		}
	}

	atLevel, err := toPropagate.Clone()
	if err != nil {
		return fmt.Errorf("cloning propagated: %w", err)
	}

	if d.Kask != nil && len(d.Kask.Tmpl) > 0 {
		atLevel, err = atLevel.ParseFiles(d.Kask.Tmpl...)
		if err != nil {
			return fmt.Errorf("parsing at-level template files: %w", err)
		}
	}

	d.Tmpl = atLevel

	for _, subdir := range d.Subdirs {
		if err := b.propagateTemplates(subdir, toPropagate); err != nil {
			return fmt.Errorf("%q: %w", subdir.SrcName, err)
		}
	}

	return nil
}

// represents a sitemap node which can be either of:
//   - non-visitable directories
//   - directories with "index.tmpl" or "README.md" file
//   - pages corresponding to .tmpl or .md files
type Node struct {
	Title    string // markdown h1, meta.yml title or the file name
	Href     string // Visitable when filled
	Parent   *Node
	Children []*Node
}

func isToStrip(d *dir2) bool {
	return !(d != nil && d.Meta != nil && d.Meta.PreserveOrdering)
}

// TODO: domain prefix
// NOTE: Split if internal (src file) and external (href) path syntaxes diverge
func canonicalize(dst string) string {
	if !strings.HasPrefix(dst, "/") {
		dst = "/" + dst
	}
	if dst == "/." {
		dst = "/"
	}
	if !strings.Contains(filepath.Base(dst), ".") && !strings.HasSuffix(dst, "/") {
		dst = dst + "/"
	}
	return dst
}

func (b *builder) toNode(d *dir2, parent *Node) (*Node, error) {
	n := &Node{
		Title:    "",
		Href:     "",
		Parent:   parent,
		Children: []*Node{},
	}

	for _, page := range slices.Concat(d.PagesTmpl, d.PagesMarkdown) {
		title, err := decideOnTitle(filepath.Join(b.args.Src, page), filepath.Ext(page), isToStrip(d))
		if err != nil {
			return nil, fmt.Errorf("decide on title: %w", err)
		}
		base := filepath.Base(page)
		if base == "index.tmpl" || base == "README.md" {
			n.Href = canonicalize(d.DstPathEncoded)
			n.Title = title
		} else {
			href := hrefFromFilename(d.DstPathEncoded, base, isToStrip(d))
			c := &Node{
				Title:    title,
				Href:     href,
				Parent:   n,
				Children: []*Node{},
			}
			b.links[canonicalize(page)] = href
			b.leaves[pageref{d, page}] = c
			n.Children = append(n.Children, c)
		}
	}

	if n.Title == "" {
		if d.Meta != nil {
			n.Title = d.Meta.Title
		} else {
			n.Title = d.DstName
		}
	}

	b.links[canonicalize(d.SrcPath)] = d.DstPathEncoded
	b.leaves[pageref{d, ""}] = n

	for _, subdir := range d.Subdirs {
		s, err := b.toNode(subdir, n)
		if err != nil {
			return nil, fmt.Errorf("%s: %w", d.SrcName, err)
		}
		n.Children = append(n.Children, s)
	}

	return n, nil
}

func (b *builder) renderMarkdown(d *dir2) error {
	for _, md := range d.PagesMarkdown {
		page, err := markdown.ToHtml(b.args.Src, md, b.links)
		if err != nil {
			return fmt.Errorf("rendering %s: %w", md, err)
		}
		b.pagesMarkdown[md] = page
	}

	for _, subdir := range d.Subdirs {
		if err := b.renderMarkdown(subdir); err != nil {
			return fmt.Errorf("%q: %w", subdir.SrcName, err)
		}
	}

	return nil
}

// template files should access necessary information through
// the fields of this struct
type TemplateContent struct {
	Stylesheets []string
	Node, Root  *Node
	Markdown    *markdown.Page
	Time        time.Time
}

func (b *builder) execPage(dst string, tmpl *template.Template, name string, content *TemplateContent) error {
	if b.args.Verbose {
		fmt.Printf("printing %s\n", dst)
	}
	f, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("creating: %w", err)
	}
	defer f.Close()
	if _, err := fmt.Fprintln(f, fileheader); err != nil {
		return fmt.Errorf("writing the autogen notice: %w", err)
	}
	if err := tmpl.ExecuteTemplate(f, name, content); err != nil {
		return fmt.Errorf("executing: %w", err)
	}
	return nil
}

func (b *builder) execDir(d *dir2) error {
	err := os.MkdirAll(filepath.Join(b.args.Dst, d.DstPath), 0o755)
	if err != nil {
		return fmt.Errorf("creating directory: %w", err)
	}

	for _, page := range d.PagesTmpl {
		dst2 := filepath.Join(b.args.Dst, d.DstPath, "index.html")
		if filepath.Base(page) != "index.tmpl" {
			dst2 = targetFromFilename(b.args.Dst, d.DstPath, filepath.Base(page), isToStrip(d))
		}
		content := &TemplateContent{
			Stylesheets: d.Stylesheets,
			Node:        nil,
			Root:        b.root3,
			Markdown:    nil,
			Time:        b.start,
		}
		if filepath.Base(page) == "index.tmpl" {
			content.Node = b.leaves[pageref{d, ""}]
		} else {
			content.Node = b.leaves[pageref{d, page}]
		}
		tmpl, err := d.Tmpl.Clone()
		if err != nil {
			return fmt.Errorf("cloning templates for rendering page: %w", err)
		}
		tmpl, err = tmpl.ParseFiles(filepath.Join(b.args.Src, page))
		if err != nil {
			return fmt.Errorf("parsing page template %q: %w", filepath.Base(page), err)
		}
		if err := b.execPage(dst2, tmpl, "page", content); err != nil {
			return fmt.Errorf("page %q: %w", filepath.Base(page), err)
		}
	}

	for _, page := range d.PagesMarkdown {
		dst2 := filepath.Join(b.args.Dst, d.DstPath, "index.html")
		if filepath.Base(page) != "README.md" {
			dst2 = targetFromFilename(b.args.Dst, d.DstPath, filepath.Base(page), isToStrip(d))
		}
		content := &TemplateContent{
			Stylesheets: d.Stylesheets,
			Node:        nil,
			Root:        b.root3,
			Markdown:    b.pagesMarkdown[page],
			Time:        b.start,
		}
		if filepath.Base(page) == "README.md" {
			content.Node = b.leaves[pageref{d, ""}]
		} else {
			content.Node = b.leaves[pageref{d, page}]
		}
		if err := b.execPage(dst2, d.Tmpl, "markdown-page", content); err != nil {
			return fmt.Errorf("page %q: %w", filepath.Base(page), err)
		}
	}

	for _, subdir := range d.Subdirs {
		if err := b.execDir(subdir); err != nil {
			return fmt.Errorf("%q: %w", subdir.SrcName, err)
		}
	}

	return nil
}

func (b *builder) copyAssetsFolders(d *dir2) error {
	if d.SrcAssets != "" {
		err := os.MkdirAll(filepath.Join(b.args.Dst, d.DstPath), 0o755)
		if err != nil {
			return fmt.Errorf("creating directory: %w", err)
		}

		dst := filepath.Join(b.args.Dst, d.DstPath, ".assets")
		src := filepath.Join(b.args.Src, d.SrcAssets)
		if b.args.Verbose {
			fmt.Println("copying", dst)
		}

		err = copy.Dir(dst, src)
		if err != nil {
			return fmt.Errorf("copy dir: %w", err)
		}
	}

	for _, subdir := range d.Subdirs {
		if err := b.copyAssetsFolders(subdir); err != nil {
			return fmt.Errorf("%q: %w", subdir.SrcName, err)
		}
	}

	return nil
}

// [builder.Build] run separate DFS processes because there are many steps
// involving previous's complete results like templates can access to the
// sitemap which contains headers extracted from markdown files
func (b *builder) Build() error {
	root, err := directory.Inspect(b.args.Src)
	if err != nil {
		return fmt.Errorf("inspecting source directory: %w", err)
	}

	if err := b.checkCompetingEntries(root); err != nil {
		return fmt.Errorf("checking competing files and folders: %w", err)
	}

	root2 := b.toDir2(root, nil, "", "", "")

	if err := b.bundleAndPropagateStylesheets(root2, []string{}); err != nil {
		return fmt.Errorf("bundling stylesheets: %w", err)
	}

	tmpl := template.New("page")
	tmpl.Funcs(template.FuncMap{
		"trustedCss":      func(s string) template.CSS { return template.CSS(s) },
		"trustedHtml":     func(s string) template.HTML { return template.HTML(s) },
		"trustedHtmlAttr": func(s string) template.HTMLAttr { return template.HTMLAttr(s) },
		"trustedJs":       func(s string) template.JS { return template.JS(s) },
		"trustedJsStr":    func(s string) template.JSStr { return template.JSStr(s) },
		"trustedSrcSet":   func(s string) template.Srcset { return template.Srcset(s) },
		"trustedUrl":      func(s string) template.URL { return template.URL(s) },
	})

	if err := b.propagateTemplates(root2, tmpl); err != nil {
		return fmt.Errorf("bundling stylesheets: %w", err)
	}

	b.root3, err = b.toNode(root2, nil)
	if err != nil {
		return fmt.Errorf("structuring node tree: %w", err)
	}

	if err := b.renderMarkdown(root2); err != nil {
		return fmt.Errorf("rendering markdown pages: %w", err)
	}

	if err := b.execDir(root2); err != nil {
		return fmt.Errorf("executing templates: %w", err)
	}

	if err := b.copyAssetsFolders(root2); err != nil {
		return fmt.Errorf("copying assets folders: %w", err)
	}

	return nil
}

// split for testing
func newBuilder(args Args) *builder {
	return &builder{
		args:          args,
		start:         time.Now(),
		assets:        []string{},
		pagesMarkdown: map[string]*markdown.Page{},
		leaves:        map[pageref]*Node{},
		links:         map[string]string{},
	}
}

func Build(args Args) error {
	return newBuilder(args).Build()
}
