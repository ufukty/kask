package builder

import (
	"fmt"
	"html/template"
	"path/filepath"
	"strings"
	"time"

	"go.ufukty.com/kask/cmd/kask/commands/version"
	"go.ufukty.com/kask/internal/builder/directory"
	"go.ufukty.com/kask/internal/builder/markdown"
	"go.ufukty.com/kask/internal/builder/memo"
	"go.ufukty.com/kask/internal/builder/rewriter"
	"go.ufukty.com/kask/pkg/kask"
)

var fileheader = fmt.Sprintf("<!-- Do not edit. Auto-generated by Kask %s -->", version.Version)

type Args struct {
	Src, Dst string
	Domain   string
	Dev      bool // suffixes css bundles with unique ids to bypass browser caching
	Verbose  bool
}

type builder struct {
	args     Args
	acc      *memo.Accountant
	rw       *rewriter.Rewriter
	assets   []string                  // src
	markdown map[string]*kask.Markdown // src -> content
	leaves   map[string]*kask.Node     // dst -> node
	root3    *kask.Node                // for testing
	start    time.Time
}

func has[K comparable, V any](m map[K]V, k K) bool {
	_, ok := m[k]
	return ok
}

func (b *builder) checkCompetingEntries(dir *directory.Dir) error {
	b.acc.Check("builder.checkCompetingEntries start")
	defer b.acc.Check("builder.checkCompetingEntries end")

	children := map[string]int{}
	for _, subdir := range dir.Subdirs {
		children[subdir.Name] = 1
	}
	for _, page := range dir.Pages {
		if has(children, page) {
			children[page] = -1
		}
		children[page]++
	}
	duplicates := []string{}
	for child, freq := range children {
		if freq > 1 {
			duplicates = append(duplicates, child)
		}
	}
	if len(duplicates) > 0 {
		return fmt.Errorf("multiple entries sharing the same path for those: %s", strings.Join(duplicates, ", "))
	}
	for _, sub := range dir.Subdirs {
		if err := b.checkCompetingEntries(sub); err != nil {
			return fmt.Errorf("%q: %w", sub.Name, err)
		}
	}
	return nil
}

// used in assigning destination addresses, bundling css, and propagating tmpl files
type dir2 struct {
	original    *directory.Dir
	paths       paths
	subdirs     []*dir2
	stylesheets []string // dst paths
	templates   *template.Template
}

func (b *builder) toDir2(d, p *directory.Dir, parent paths) *dir2 {
	b.acc.Check("builder.toDir2 start")
	defer b.acc.Check("builder.toDir2 end")

	paths := parent.subdir(d.Name, p.IsToStrip())
	d2 := &dir2{
		original:    d,
		subdirs:     []*dir2{},
		paths:       paths,
		stylesheets: nil,
		templates:   nil,
	}
	for _, subdir := range d.Subdirs {
		d2.subdirs = append(d2.subdirs, b.toDir2(subdir, d, paths))
	}
	return d2
}

// TODO: domain prefix
func (b *builder) toNode(d *dir2, parent *kask.Node) (*kask.Node, error) {
	b.acc.Check("builder.toNode start")
	defer b.acc.Check("builder.toNode end")

	n := &kask.Node{
		Title:    "",
		Href:     "",
		Parent:   parent,
		Children: []*kask.Node{},
	}

	for _, page := range d.original.Pages {
		p := d.paths.file(page, d.original.IsToStrip()) // TODO: reuse calculated paths for later use in [builder.Build]
		title, err := pageTitle(b.args.Src, p)
		if err != nil {
			return nil, fmt.Errorf("decide on title: %w", err)
		}
		if page == "README.md" || page == "index.tmpl" {
			n.Href = p.url
			n.Title = title
			b.rw.Bank(p.src, p.url)
			b.rw.Bank(filepath.Dir(p.src), p.url)
		} else {
			c := &kask.Node{
				Title:    title,
				Href:     p.url,
				Parent:   n,
				Children: []*kask.Node{},
			}
			b.rw.Bank(p.src, p.url)
			b.leaves[p.url] = c
			n.Children = append(n.Children, c)
		}
	}

	if n.Title == "" {
		if d.original.Meta != nil {
			n.Title = d.original.Meta.Title
		} else {
			n.Title = filepath.Base(d.paths.dst)
		}
	}

	b.leaves[d.paths.url] = n

	for _, subdir := range d.subdirs {
		s, err := b.toNode(subdir, n)
		if err != nil {
			return nil, fmt.Errorf("%s: %w", filepath.Base(d.paths.src), err)
		}
		n.Children = append(n.Children, s)
	}

	return n, nil
}

func (b *builder) renderMarkdown(d *dir2) error {
	b.acc.Check("builder.renderMarkdown start")
	defer b.acc.Check("builder.renderMarkdown end")

	for _, page := range d.original.Pages {
		if filepath.Ext(page) == ".md" {
			p := d.paths.file(page, d.original.IsToStrip())
			html, err := markdown.ToHtml(b.args.Src, p.src, b.rw)
			if err != nil {
				return fmt.Errorf("rendering %s: %w", page, err)
			}
			b.markdown[p.src] = html
		}
	}
	for _, subdir := range d.subdirs {
		if err := b.renderMarkdown(subdir); err != nil {
			return fmt.Errorf("%q: %w", filepath.Base(subdir.paths.src), err)
		}
	}
	return nil
}

// [builder.Build] run separate DFS processes because there are many steps
// involving previous's complete results like templates can access to the
// sitemap which contains headers extracted from markdown files
func (b *builder) Build() error {
	b.acc.Check("builder.Build start")
	defer b.acc.Check("builder.Build end")

	root, err := directory.Inspect(b.args.Src)
	if err != nil {
		return fmt.Errorf("inspecting source directory: %w", err)
	}
	if err := b.checkCompetingEntries(root); err != nil {
		return fmt.Errorf("checking competing files and folders: %w", err)
	}
	root2 := b.toDir2(root, nil, paths{src: "."})
	if err := b.bundleAndPropagateStylesheets(root2, []string{}); err != nil {
		return fmt.Errorf("bundling stylesheets: %w", err)
	}
	if err := b.propagateTemplates(root2, newTemplateSet()); err != nil {
		return fmt.Errorf("bundling stylesheets: %w", err)
	}
	b.root3, err = b.toNode(root2, nil)
	if err != nil {
		return fmt.Errorf("structuring node tree: %w", err)
	}
	if err := b.renderMarkdown(root2); err != nil {
		return fmt.Errorf("rendering markdown pages: %w", err)
	}
	if err := b.execDir(root2); err != nil {
		return fmt.Errorf("executing templates: %w", err)
	}
	if err := b.copyAssetsFolders(root2); err != nil {
		return fmt.Errorf("copying assets folders: %w", err)
	}
	return nil
}

// split for testing
func newBuilder(args Args) *builder {
	return &builder{
		args:     args,
		acc:      memo.NewAccountant(),
		rw:       rewriter.New(),
		assets:   []string{},
		markdown: map[string]*kask.Markdown{},
		leaves:   map[string]*kask.Node{},
		start:    time.Now(),
	}
}

func Build(args Args) error {
	return newBuilder(args).Build()
}
