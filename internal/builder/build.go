package builder

import (
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"
	"time"

	"github.com/ufukty/kask/cmd/kask/commands/version"
	"github.com/ufukty/kask/internal/builder/bundle"
	"github.com/ufukty/kask/internal/builder/directory"
	"github.com/ufukty/kask/internal/builder/markdown"
)

var fileheader = fmt.Sprintf("<!-- Do not edit. Auto-generated by Kask %s -->", version.Version)

type Args struct {
	Src, Dst string
	Domain   string
	Dev      bool // suffixes css bundles with unique ids to bypass browser caching
	Verbose  bool
}

type pageref struct {
	dir  *dir2
	page string
}

type builder struct {
	args Args

	start time.Time

	assets        []string                  // src paths
	stylesheets   map[string]string         // src path -> content
	pagesMarkdown map[string]*markdown.Page // src path -> content
	leaves        map[pageref]*Node         // to access nodes built for sitemap beforehand
}

func has[K comparable, V any](m map[K]V, k K) bool {
	_, ok := m[k]
	return ok
}

func (b *builder) checkCompetingEntries(dir *directory.Dir) error {
	children := map[string]int{}
	for _, subdir := range dir.Subdirs {
		children[subdir.Name] = 1
	}
	for _, page := range dir.PagesHtml {
		if has(children, page) {
			children[page] = -1
		}
		children[page]++
	}
	for _, page := range dir.PagesMarkdown {
		if has(children, page) {
			children[page] = -1
		}
		children[page]++
	}
	duplicates := []string{}
	for child, freq := range children {
		if freq > 1 {
			duplicates = append(duplicates, child)
		}
	}
	if len(duplicates) > 0 {
		return fmt.Errorf("multiple entries sharing the same path for those: %s", strings.Join(duplicates, ", "))
	}
	for _, sub := range dir.Subdirs {
		if err := b.checkCompetingEntries(sub); err != nil {
			return fmt.Errorf("%q: %w", sub.Name, err)
		}
	}
	return nil
}

// used in assigning destination addresses, bundling css, and propagating tmpl files
type dir2 struct {
	Kask *directory.Kask

	SrcName, SrcPath, SrcAssets string
	DstName, DstPath, DstAssets string // path encoded

	Subdirs []*dir2

	PagesMarkdown []string // src paths
	PagesHtml     []string // src paths
	Stylesheets   []string // dst paths

	Tmpl *template.Template
}

func (b *builder) toDir2(d *directory.Dir, srcparent, dstparent string) *dir2 {
	srcparent = filepath.Join(srcparent, d.Name)
	dstparent = filepath.Join(dstparent, url.PathEscape(d.Name)) // escaped
	d2 := &dir2{
		Kask: d.Kask,

		Subdirs: []*dir2{},

		SrcName:   d.Name,
		SrcPath:   srcparent,
		SrcAssets: d.Assets,

		DstName:   url.PathEscape(d.Name),
		DstPath:   dstparent,
		DstAssets: "",

		PagesMarkdown: d.PagesMarkdown,
		PagesHtml:     d.PagesHtml,
		Stylesheets:   nil,

		Tmpl: nil,
	}
	for _, subdir := range d.Subdirs {
		d2.Subdirs = append(d2.Subdirs, b.toDir2(subdir, srcparent, dstparent))
	}
	return d2
}

func (b *builder) bundleAndPropagateStylesheets(d *dir2, toPropagate []string) error {
	d.Stylesheets = []string{}

	if d.Kask != nil && d.Kask.Propagate != nil && len(d.Kask.Propagate.Css) > 0 {
		css, err := bundle.Files(d.Kask.Propagate.Css)
		if err != nil {
			return fmt.Errorf("bundling propagated css files: %w", err)
		}
		dst := filepath.Join(d.DstPath, "styles.propagate.css")
		b.stylesheets[dst] = css
		d.Stylesheets = append(d.Stylesheets, dst)
		toPropagate = append(toPropagate, dst)
	}

	if d.Kask != nil && len(d.Kask.Css) > 0 {
		css, err := bundle.Files(d.Kask.Css)
		if err != nil {
			return fmt.Errorf("bundling at-level css files: %w", err)
		}
		dst := filepath.Join(d.DstPath, "styles.css")
		b.stylesheets[dst] = css
		d.Stylesheets = append(d.Stylesheets, dst)
	}

	for _, subdir := range d.Subdirs {
		if err := b.bundleAndPropagateStylesheets(subdir, slices.Clone(toPropagate)); err != nil {
			return fmt.Errorf("%s: %w", subdir.SrcName, err)
		}
	}

	return nil
}

func (b *builder) propagateTemplates(d *dir2, toPropagate *template.Template) error {
	var err error

	if d.Kask != nil && d.Kask.Propagate != nil && len(d.Kask.Propagate.Tmpl) > 0 {
		toPropagate, err = d.Tmpl.ParseFiles(d.Kask.Propagate.Tmpl...)
		if err != nil {
			return fmt.Errorf("parsing to-propagate template files: %w", err)
		}
	}

	atLevel, err := toPropagate.Clone()
	if err != nil {
		return fmt.Errorf("cloning propagated: %w", err)
	}

	if d.Kask != nil && len(d.Kask.Tmpl) > 0 {
		atLevel, err = atLevel.ParseFiles(d.Kask.Tmpl...)
		if err != nil {
			return fmt.Errorf("parsing at-level template files: %w", err)
		}
	}

	d.Tmpl = atLevel

	for _, subdir := range d.Subdirs {
		if err := b.propagateTemplates(subdir, toPropagate); err != nil {
			return fmt.Errorf("%s: %w", subdir.SrcName, err)
		}
	}

	return nil
}

func (b *builder) renderMarkdown(d *dir2) error {
	for _, md := range d.PagesMarkdown {
		page, err := markdown.ToHtml(filepath.Join(b.args.Src, md))
		if err != nil {
			return fmt.Errorf("rendering %s: %w", md, err)
		}
		b.pagesMarkdown[md] = page
	}

	for _, subdir := range d.Subdirs {
		if err := b.renderMarkdown(subdir); err != nil {
			return fmt.Errorf("%s: %w", subdir.SrcName, err)
		}
	}

	return nil
}

// represents a sitemap node which can be either of:
//   - non-visitable directories
//   - directories with "index.html" or "README.md" file
//   - pages corresponding to .html or .md files
type Node struct {
	Title    string // markdown h1, meta.yml title or the file name
	Href     string // Visitable when filled
	Children []*Node
}

func containsIndexHtml(d *dir2) bool {
	return slices.ContainsFunc(d.PagesHtml, func(path string) bool {
		return filepath.Base(path) == "index.html"
	})
}

func containsReadmeMd(d *dir2) bool {
	return slices.ContainsFunc(d.PagesMarkdown, func(path string) bool {
		return filepath.Base(path) == "README.md"
	})
}

func isVisitable(d *dir2) bool {
	return containsIndexHtml(d) || containsReadmeMd(d)
}

// TODO: consider prefixing [Node.Href] with the domain for absolute links
// TODO: consider setting [Node.Children] on leaves to nil
// DONE: overwrite dir title with README.md header
func (b *builder) toNode(d *dir2) *Node {
	n := &Node{
		Title:    d.SrcName,
		Href:     "",
		Children: []*Node{},
	}

	if isVisitable(d) {
		n.Href = "/" + filepath.Join(d.DstPath) // TODO: domain prefix
	}

	for _, page := range d.PagesHtml {
		if filepath.Base(page) != "index.html" {
			c := &Node{
				Title:    filepath.Base(strings.ToTitle(page)),
				Href:     "/" + filepath.Join(d.DstPath, url.PathEscape(filepath.Base(page))),
				Children: []*Node{}, // initialized and empty TODO: consider nil
			}
			b.leaves[pageref{d, page}] = c
			n.Children = append(n.Children, c)
		}
	}

	for _, page := range d.PagesMarkdown {
		title := filepath.Base(strings.ToTitle(page)) // default
		if md, ok := b.pagesMarkdown[page]; ok && md.Toc != nil && len(md.Toc.Children) > 0 {
			title = md.Toc.Children[0].Title
		}
		if filepath.Base(page) == "README.md" {
			n.Title = title
		} else {
			c := &Node{
				Title:    title,
				Href:     "/" + filepath.Join(d.DstPath, url.PathEscape(strings.TrimSuffix(filepath.Base(page), ".md")+".html")),
				Children: []*Node{}, // initialized and empty TODO: consider nil
			}
			b.leaves[pageref{d, page}] = c
			n.Children = append(n.Children, c)
		}
	}

	b.leaves[pageref{d, ""}] = n

	for _, subdir := range d.Subdirs {
		n.Children = append(n.Children, b.toNode(subdir))
	}

	return n
}

// template files should access necessary information through
// the fields of this struct
type TemplateContent struct {
	Stylesheets []string
	Node, Root  *Node
	Markdown    *markdown.Page
	Time        time.Time
}

func (b *builder) execPage(dst string, tmpl *template.Template, content *TemplateContent) error {
	if b.args.Verbose {
		fmt.Printf("printing %s\n", dst)
	}
	f, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("creating: %w", err)
	}
	defer f.Close()
	if _, err := fmt.Fprintln(f, fileheader); err != nil {
		return fmt.Errorf("writing the autogen notice: %w", err)
	}
	if err := tmpl.ExecuteTemplate(f, "page", content); err != nil {
		return fmt.Errorf("executing: %w", err)
	}
	return nil
}

func (b *builder) execDir(d *dir2, root *Node) error {
	err := os.MkdirAll(filepath.Join(b.args.Dst, d.SrcPath), 0755)
	if err != nil {
		return fmt.Errorf("creating directory: %w", err)
	}

	for _, page := range d.PagesHtml {
		dst2 := filepath.Join(b.args.Dst, page)
		content := &TemplateContent{
			Stylesheets: d.Stylesheets,
			Node:        nil,
			Root:        root,
			Markdown:    nil,
			Time:        b.start,
		}
		if filepath.Base(page) == "index.html" {
			content.Node = b.leaves[pageref{d, ""}]
		} else {
			content.Node = b.leaves[pageref{d, page}]
		}
		tmpl, err := d.Tmpl.ParseFiles(filepath.Join(b.args.Src, page))
		if err != nil {
			return fmt.Errorf("parsing page template %q: %w", filepath.Base(page), err)
		}
		if err := b.execPage(dst2, tmpl, content); err != nil {
			return fmt.Errorf("page %q: %w", filepath.Base(page), err)
		}
	}

	for _, page := range d.PagesMarkdown {
		dst2 := filepath.Join(b.args.Dst, d.SrcPath)
		if filepath.Base(page) != "README.md" {
			dst2 = filepath.Join(b.args.Dst, d.SrcPath, strings.TrimSuffix(filepath.Base(page), ".md")+".html")
		}
		content := &TemplateContent{
			Stylesheets: d.Stylesheets,
			Node:        nil,
			Root:        root,
			Markdown:    b.pagesMarkdown[page],
			Time:        b.start,
		}
		if filepath.Base(page) == "index.html" {
			content.Node = b.leaves[pageref{d, ""}]
		} else {
			content.Node = b.leaves[pageref{d, page}]
		}
		if err := b.execPage(dst2, d.Tmpl, content); err != nil {
			return fmt.Errorf("page %q: %w", filepath.Base(page), err)
		}
	}

	// if d.Checks.HasAssetDir {
	// 	err := copy.Dir(filepath.Join(dstroot, d.InSitePath, ".assets"), filepath.Join(d.SiteRoot, d.InSitePath, ".assets"))
	// 	if err != nil {
	// 		return fmt.Errorf("copyDir: %w", err)
	// 	}
	// }

	for _, subdir := range d.Subdirs {
		if err := b.execDir(subdir, root); err != nil {
			return fmt.Errorf("%s: %w", subdir.SrcName, err)
		}
	}

	return nil
}

// [builder.Build] run separate DFS processes because there are many steps
// involving previous's complete results like templates can access to the
// sitemap which contains headers extracted from markdown files
func (b *builder) Build() error {
	root, err := directory.Inspect(b.args.Src)
	if err != nil {
		return fmt.Errorf("inspecting source directory: %w", err)
	}

	if err := b.checkCompetingEntries(root); err != nil {
		return fmt.Errorf("checking competing files and folders: %w", err)
	}

	root2 := b.toDir2(root, "", "")

	if err := b.bundleAndPropagateStylesheets(root2, []string{}); err != nil {
		return fmt.Errorf("bundling stylesheets: %w", err)
	}

	if err := b.propagateTemplates(root2, template.New("page")); err != nil {
		return fmt.Errorf("bundling stylesheets: %w", err)
	}

	if err := b.renderMarkdown(root2); err != nil {
		return fmt.Errorf("rendering markdown pages: %w", err)
	}

	root3 := b.toNode(root2)

	if err := b.execDir(root2, root3); err != nil {
		return fmt.Errorf("executing templates: %w", err)
	}

	return nil
}

func Build(args Args) error {
	b := &builder{
		stylesheets:   map[string]string{},
		args:          args,
		start:         time.Now(),
		assets:        []string{},
		pagesMarkdown: map[string]*markdown.Page{},
		leaves:        map[pageref]*Node{},
	}
	return b.Build()
}
