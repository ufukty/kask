package builder

import (
	"fmt"
	"html/template"
	"io"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"time"

	"go.ufukty.com/kask/cmd/kask/commands/version"
	"go.ufukty.com/kask/internal/builder/bundle"
	"go.ufukty.com/kask/internal/builder/copy"
	"go.ufukty.com/kask/internal/builder/directory"
	"go.ufukty.com/kask/internal/builder/markdown"
	"go.ufukty.com/kask/internal/builder/rewriter"
	"go.ufukty.com/kask/pkg/kask"
)

var fileheader = fmt.Sprintf("<!-- Do not edit. Auto-generated by Kask %s -->", version.Version)

type Args struct {
	Src, Dst string
	Domain   string
	Dev      bool // suffixes css bundles with unique ids to bypass browser caching
	Verbose  bool
}

type pageref struct {
	dir  *dir2
	page string
}

type builder struct {
	args     Args
	rw       *rewriter.Rewriter
	assets   []string                  // src paths
	markdown map[string]*kask.Markdown // src path -> content
	leaves   map[pageref]*kask.Node    // to access nodes built for sitemap beforehand
	root3    *kask.Node                // for testing
	start    time.Time
}

func has[K comparable, V any](m map[K]V, k K) bool {
	_, ok := m[k]
	return ok
}

func (b *builder) checkCompetingEntries(dir *directory.Dir) error {
	children := map[string]int{}
	for _, subdir := range dir.Subdirs {
		children[subdir.Name] = 1
	}
	for _, page := range dir.Pages {
		if has(children, page) {
			children[page] = -1
		}
		children[page]++
	}
	duplicates := []string{}
	for child, freq := range children {
		if freq > 1 {
			duplicates = append(duplicates, child)
		}
	}
	if len(duplicates) > 0 {
		return fmt.Errorf("multiple entries sharing the same path for those: %s", strings.Join(duplicates, ", "))
	}
	for _, sub := range dir.Subdirs {
		if err := b.checkCompetingEntries(sub); err != nil {
			return fmt.Errorf("%q: %w", sub.Name, err)
		}
	}
	return nil
}

// used in assigning destination addresses, bundling css, and propagating tmpl files
type dir2 struct {
	original    *directory.Dir
	paths       paths
	subdirs     []*dir2
	stylesheets []string // dst paths
	templates   *template.Template
}

func (b *builder) toDir2(d, p *directory.Dir, parent paths) *dir2 {
	paths := parent.subdir(d.Name, p.IsToStrip())
	d2 := &dir2{
		original:    d,
		subdirs:     []*dir2{},
		paths:       paths,
		stylesheets: nil,
		templates:   nil,
	}
	for _, subdir := range d.Subdirs {
		d2.subdirs = append(d2.subdirs, b.toDir2(subdir, d, paths))
	}
	return d2
}

func (b *builder) write(dst, content string) error {
	if b.args.Verbose {
		fmt.Println("writing", dst)
	}
	err := os.MkdirAll(filepath.Dir(dst), 0o755)
	if err != nil {
		return fmt.Errorf("creating directory: %w", err)
	}
	f, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("creating: %w", err)
	}
	defer f.Close()
	_, err = io.Copy(f, strings.NewReader(content))
	if err != nil {
		return fmt.Errorf("copying: %w", err)
	}
	return nil
}

func (b *builder) bundleAndPropagateStylesheets(d *dir2, toPropagate []string) error {
	d.stylesheets = slices.Clone(toPropagate)

	if d.original.Kask != nil && d.original.Kask.Propagate != nil && len(d.original.Kask.Propagate.Css) > 0 {
		css, err := bundle.Files(d.original.Kask.Propagate.Css)
		if err != nil {
			return fmt.Errorf("bundling propagated css file: %w", err)
		}
		dst := "/" + filepath.Join(d.paths.dst, "styles.propagate.css")
		if err := b.write(filepath.Join(b.args.Dst, dst), css); err != nil {
			return fmt.Errorf("writing propagated css file: %w", err)
		}
		d.stylesheets = append(d.stylesheets, dst)
		toPropagate = append(toPropagate, dst)
	}

	if d.original.Kask != nil && len(d.original.Kask.Css) > 0 {
		css, err := bundle.Files(d.original.Kask.Css)
		if err != nil {
			return fmt.Errorf("bundling at-level css file: %w", err)
		}
		dst := "/" + filepath.Join(d.paths.dst, "styles.css")
		if err := b.write(filepath.Join(b.args.Dst, dst), css); err != nil {
			return fmt.Errorf("writing at-level css file: %w", err)
		}
		d.stylesheets = append(d.stylesheets, dst)
	}

	for _, subdir := range d.subdirs {
		if err := b.bundleAndPropagateStylesheets(subdir, slices.Clone(toPropagate)); err != nil {
			return fmt.Errorf("%q: %w", filepath.Base(subdir.paths.src), err)
		}
	}

	return nil
}

func (b *builder) propagateTemplates(d *dir2, toPropagate *template.Template) error {
	var err error

	if d.original.Kask != nil && d.original.Kask.Propagate != nil && len(d.original.Kask.Propagate.Tmpl) > 0 {
		toPropagate, err = toPropagate.ParseFiles(d.original.Kask.Propagate.Tmpl...)
		if err != nil {
			return fmt.Errorf("parsing to-propagate template files: %w", err)
		}
	}

	atLevel, err := toPropagate.Clone()
	if err != nil {
		return fmt.Errorf("cloning propagated: %w", err)
	}

	if d.original.Kask != nil && len(d.original.Kask.Tmpl) > 0 {
		atLevel, err = atLevel.ParseFiles(d.original.Kask.Tmpl...)
		if err != nil {
			return fmt.Errorf("parsing at-level template files: %w", err)
		}
	}

	d.templates = atLevel

	for _, subdir := range d.subdirs {
		if err := b.propagateTemplates(subdir, toPropagate); err != nil {
			return fmt.Errorf("%q: %w", filepath.Base(subdir.paths.src), err)
		}
	}

	return nil
}

// TODO: domain prefix
func (b *builder) toNode(d *dir2, parent *kask.Node) (*kask.Node, error) {
	n := &kask.Node{
		Title:    "",
		Href:     "",
		Parent:   parent,
		Children: []*kask.Node{},
	}

	for _, page := range d.original.Pages {
		p := d.paths.file(page, d.original.IsToStrip()) // TODO: reuse calculated paths for later use in [builder.Build]
		title, err := pageTitle(b.args.Src, p)
		if err != nil {
			return nil, fmt.Errorf("decide on title: %w", err)
		}
		if page == "README.md" || page == "index.tmpl" {
			n.Href = p.url
			n.Title = title
			b.rw.Bank(p.src, p.url)
			b.rw.Bank(filepath.Dir(p.src), p.url)
		} else {
			c := &kask.Node{
				Title:    title,
				Href:     p.url,
				Parent:   n,
				Children: []*kask.Node{},
			}
			b.rw.Bank(p.src, p.url)
			b.leaves[pageref{d, p.src}] = c
			n.Children = append(n.Children, c)
		}
	}

	if n.Title == "" {
		if d.original.Meta != nil {
			n.Title = d.original.Meta.Title
		} else {
			n.Title = filepath.Base(d.paths.dst)
		}
	}

	b.leaves[pageref{d, ""}] = n

	for _, subdir := range d.subdirs {
		s, err := b.toNode(subdir, n)
		if err != nil {
			return nil, fmt.Errorf("%s: %w", filepath.Base(d.paths.src), err)
		}
		n.Children = append(n.Children, s)
	}

	return n, nil
}

func (b *builder) renderMarkdown(d *dir2) error {
	for _, page := range d.original.Pages {
		if filepath.Ext(page) == ".md" {
			p := d.paths.file(page, d.original.IsToStrip())
			html, err := markdown.ToHtml(b.args.Src, p.src, b.rw)
			if err != nil {
				return fmt.Errorf("rendering %s: %w", page, err)
			}
			b.markdown[p.src] = html
		}
	}

	for _, subdir := range d.subdirs {
		if err := b.renderMarkdown(subdir); err != nil {
			return fmt.Errorf("%q: %w", filepath.Base(subdir.paths.src), err)
		}
	}

	return nil
}

func (b *builder) copyAssetsFolders(d *dir2) error {
	if d.original.Assets {
		err := os.MkdirAll(filepath.Join(b.args.Dst, d.paths.dst), 0o755)
		if err != nil {
			return fmt.Errorf("creating directory: %w", err)
		}

		dst := filepath.Join(b.args.Dst, d.paths.dst, ".assets")
		src := filepath.Join(b.args.Src, d.paths.src, ".assets")
		if b.args.Verbose {
			fmt.Println("copying", dst)
		}

		err = copy.Dir(dst, src)
		if err != nil {
			return fmt.Errorf("copy dir: %w", err)
		}
	}

	for _, subdir := range d.subdirs {
		if err := b.copyAssetsFolders(subdir); err != nil {
			return fmt.Errorf("%q: %w", filepath.Base(subdir.paths.src), err)
		}
	}

	return nil
}

// [builder.Build] run separate DFS processes because there are many steps
// involving previous's complete results like templates can access to the
// sitemap which contains headers extracted from markdown files
func (b *builder) Build() error {
	root, err := directory.Inspect(b.args.Src)
	if err != nil {
		return fmt.Errorf("inspecting source directory: %w", err)
	}

	if err := b.checkCompetingEntries(root); err != nil {
		return fmt.Errorf("checking competing files and folders: %w", err)
	}

	root2 := b.toDir2(root, nil, paths{src: "."})

	if err := b.bundleAndPropagateStylesheets(root2, []string{}); err != nil {
		return fmt.Errorf("bundling stylesheets: %w", err)
	}

	tmpl := template.New("page")
	tmpl.Funcs(template.FuncMap{
		"trustedCss":      func(s string) template.CSS { return template.CSS(s) },
		"trustedHtml":     func(s string) template.HTML { return template.HTML(s) },
		"trustedHtmlAttr": func(s string) template.HTMLAttr { return template.HTMLAttr(s) },
		"trustedJs":       func(s string) template.JS { return template.JS(s) },
		"trustedJsStr":    func(s string) template.JSStr { return template.JSStr(s) },
		"trustedSrcSet":   func(s string) template.Srcset { return template.Srcset(s) },
		"trustedUrl":      func(s string) template.URL { return template.URL(s) },
	})

	if err := b.propagateTemplates(root2, tmpl); err != nil {
		return fmt.Errorf("bundling stylesheets: %w", err)
	}

	b.root3, err = b.toNode(root2, nil)
	if err != nil {
		return fmt.Errorf("structuring node tree: %w", err)
	}

	if err := b.renderMarkdown(root2); err != nil {
		return fmt.Errorf("rendering markdown pages: %w", err)
	}

	if err := b.execDir(root2); err != nil {
		return fmt.Errorf("executing templates: %w", err)
	}

	if err := b.copyAssetsFolders(root2); err != nil {
		return fmt.Errorf("copying assets folders: %w", err)
	}

	return nil
}

// split for testing
func newBuilder(args Args) *builder {
	return &builder{
		args:     args,
		rw:       rewriter.New(),
		assets:   []string{},
		markdown: map[string]*kask.Markdown{},
		leaves:   map[pageref]*kask.Node{},
		start:    time.Now(),
	}
}

func Build(args Args) error {
	return newBuilder(args).Build()
}
