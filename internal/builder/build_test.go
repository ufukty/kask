package builder

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"testing"

	"go.ufukty.com/kask/internal/builder/copy"
	"go.ufukty.com/kask/internal/scales"
	"go.ufukty.com/kask/pkg/kask"
)

func check(tmp, path string) bool {
	_, err := os.Stat(filepath.Join(tmp, path))
	return err == nil
}

func dfs(n []*kask.Node, f func([]*kask.Node)) {
	f(n)
	for _, c := range n[len(n)-1].Children {
		dfs(append(slices.Clone(n), c), f)
	}
}

func each(ns []*kask.Node, f func(*kask.Node) string) []string {
	ss := make([]string, 0, len(ns))
	for _, n := range ns {
		ss = append(ss, f(n))
	}
	return ss
}

func buildTestSite(path string) (*builder, string) {
	tmp, err := os.MkdirTemp(os.TempDir(), "kask-test-build-*")
	if err != nil {
		panic(fmt.Errorf("buildTestSite: os.MkdirTemp: %w", err))
	}
	b := newBuilder(Args{Src: path, Dst: tmp, Dev: true, Verbose: false})
	err = b.Build()
	if err != nil {
		panic(fmt.Errorf("buildTestSite: b.Build: %w", err))
	}
	return b, tmp
}

func TestBuilder_renderWebPages(t *testing.T) {
	_, tmp := buildTestSite("testdata/web")
	f, err := os.ReadFile(filepath.Join(tmp, "index.html"))
	if err != nil {
		t.Errorf("prep, read file: %v", err)
	}
	if !strings.Contains(string(f), "<h1>Title</h1>") {
		t.Error("expected markdown content not found.")
	}
}

func TestBuilder_renderMarkdownPages(t *testing.T) {
	_, tmp := buildTestSite("testdata/markdown-content")
	f, err := os.ReadFile(filepath.Join(tmp, "index.html"))
	if err != nil {
		t.Errorf("prep, read file: %v", err)
	}
	if !strings.Contains(string(f), `<h1 id="title">Title</h1>`) {
		t.Error("expected content not found.")
	}
}

func ExampleBuilder_renderMarkdownToc() {
	_, tmp := buildTestSite("testdata/markdown-toc")
	f, err := os.ReadFile(filepath.Join(tmp, "index.html"))
	if err != nil {
		panic(fmt.Errorf("prep, read file: %w", err))
	}
	fmt.Println(string(f))
	// Output:
	// <!-- Do not edit. Auto-generated by Kask  -->
	// <a data-level="1" href="#h1-lorem">H1 Lorem</a>
	// <a data-level="2" href="#h2-ipsum">H2 Ipsum</a>
	// <a data-level="3" href="#h3-dolor">H3 Dolor</a>
	// <a data-level="4" href="#h4-sit">H4 Sit</a>
	// <a data-level="2" href="#h2-amet">H2 Amet</a>
	// <a data-level="2" href="#h2-consectetur">H2 Consectetur</a>
	// <a data-level="3" href="#h3-adipscing">H3 Adipscing</a>
}

func TestBuilder_recursiveTemplating(t *testing.T) {
	_, tmp := buildTestSite("testdata/recursive-templating")
	f, err := os.ReadFile(filepath.Join(tmp, "a/b/c/page.html"))
	if err != nil {
		t.Errorf("prep, read file: %v", err)
	}
	if !strings.Contains(string(f), "./a/b/c/Page") {
		t.Error("expected markdown content not found.")
	}
}

func TestBuilder_propagated(t *testing.T) {
	tcs := []string{"web", "mixed", "markdown"}
	for _, tc := range tcs {
		t.Run(tc, func(t *testing.T) {
			tmp, err := os.MkdirTemp(os.TempDir(), "kask-test-build-*")
			if err != nil {
				t.Errorf("os.MkdirTemp: %v", err)
			}
			fmt.Println("temp folder:", tmp)

			a := Args{
				Src:     filepath.Join("testdata/propagated", tc),
				Dst:     tmp,
				Dev:     true,
				Verbose: true,
			}
			err = Build(a)
			if err != nil {
				t.Errorf("act, unexpected error: %v", err)
			}
		})
	}
}

func ExampleBuilder_strippedOrderingHrefs() {
	b, _ := buildTestSite("testdata/stripped-ordering")
	dfs([]*kask.Node{b.root3}, func(n []*kask.Node) { fmt.Println(n[len(n)-1].Href) })
	// Output:
	// /
	// /career.html
	// /docs.html
	// /products.html
	// /about/
	// /contact/
}

func ExampleBuilder_strippedOrderingTitles() {
	b, _ := buildTestSite("testdata/stripped-ordering")
	dfs([]*kask.Node{b.root3}, func(n []*kask.Node) { fmt.Println(n[len(n)-1].Title) })
	// Output:
	// Website Title
	// Career Title
	// Docs Title
	// Products Title
	// About Title
	// Contact Title
}

func ExampleBuilder_strippedOrderingBreadcrumbs() {
	b, _ := buildTestSite("testdata/stripped-ordering")
	dfs([]*kask.Node{b.root3}, func(n []*kask.Node) {
		bs := each(n, func(n *kask.Node) string { return n.Title })
		fmt.Println(strings.Join(bs, " / "))
	})
	// Output:
	// Website Title
	// Website Title / Career Title
	// Website Title / Docs Title
	// Website Title / Products Title
	// Website Title / About Title
	// Website Title / Contact Title
}

func ExampleBuilder_preservedOrderingHrefs() {
	b, _ := buildTestSite("testdata/preserved-ordering")
	dfs([]*kask.Node{b.root3}, func(n []*kask.Node) { fmt.Println(n[len(n)-1].Href) })
	// Output:
	// /
	// /1.career.html
	// /2.docs.html
	// /3.products.html
	// /1.about/
	// /2.contact/
}

func ExampleBuilder_preservedOrderingTitles() {
	b, _ := buildTestSite("testdata/preserved-ordering")
	dfs([]*kask.Node{b.root3}, func(n []*kask.Node) { fmt.Println(n[len(n)-1].Title) })
	// Output:
	// Website Title
	// Career Title
	// Docs Title
	// Products Title
	// About Title
	// Contact Title
}

func ExampleBuilder_preservedOrderingBreadcrumbs() {
	b, _ := buildTestSite("testdata/preserved-ordering")
	dfs([]*kask.Node{b.root3}, func(n []*kask.Node) {
		bs := each(n, func(n *kask.Node) string { return n.Title })
		fmt.Println(strings.Join(bs, " / "))
	})
	// Output:
	// Website Title
	// Website Title / Career Title
	// Website Title / Docs Title
	// Website Title / Products Title
	// Website Title / About Title
	// Website Title / Contact Title
}

func TestBuilder_cssSplitting(t *testing.T) {
	_, tmp := buildTestSite("testdata/css-splitting")
	fmt.Println(tmp)

	t.Run("linking the scorrect stylesheets", func(t *testing.T) {
		f, err := os.ReadFile(filepath.Join(tmp, "a/index.html"))
		if err != nil {
			t.Errorf("prep, read file: %v", err)
		}
		content := string(f)
		if strings.Contains(content, `"/styles.css"`) {
			t.Error("page of subsection should NOT link the root section's non-propagated styles")
		}
		if !strings.Contains(content, `"/styles.propagate.css"`) {
			t.Error("page of subsection should link the root section's propagated styles")
		}
		if !strings.Contains(content, `"/a/styles.propagate.css"`) {
			t.Error("page should link its section's propagated styles")
		}
		if !strings.Contains(content, `"/a/styles.css"`) {
			t.Error("page should link its section's non-propagated styles")
		}
	})

	tcs := map[string]string{
		"/styles.css":             ":root {}",
		"/styles.propagate.css":   ":root.propagated {}",
		"/a/styles.css":           ".a {}",
		"/a/styles.propagate.css": ".a.propagated {}",
	}

	for ss, expected := range tcs {
		t.Run(fmt.Sprintf("stylesheet contents/%s", strings.ReplaceAll(ss, "/", "\\")), func(t *testing.T) {
			f, err := os.ReadFile(filepath.Join(tmp, ss))
			if err != nil {
				t.Errorf("prep, read stylesheet: %v", err)
			}
			if !strings.Contains(string(f), "") {
				t.Errorf("assert, not found: %q", expected)
			}
		})
	}
}

func ExampleBuilder_titles() {
	b, _ := buildTestSite("testdata/titles")
	dfs([]*kask.Node{b.root3}, func(n []*kask.Node) { fmt.Println(n[len(n)-1].Title) })
	// Output:
	// .
	// An Anonymous Markdown Page
	// An Anonymous Web Page
	// A beatiful markdown file with title
	// A beautiful tmpl file with title tag
}

func ExampleBuilder_metaTitle() {
	b, _ := buildTestSite("testdata/meta-title")
	dfs([]*kask.Node{b.root3}, func(n []*kask.Node) { fmt.Println(n[len(n)-1].Title) })
	// Output:
	// My Beautiful Site
	// Page
	// My Beautiful Section
	// Page
}

func assertfile(t *testing.T, tmp, path string) {
	t.Run(strings.ReplaceAll(path, "/", "\\"), func(t *testing.T) {
		if !check(tmp, path) {
			t.Errorf("assert, file not found: %s", path)
		}
	})
}

func TestBuilder_assets(t *testing.T) {
	_, tmp := buildTestSite("testdata/assets")
	tcs := []string{".assets/sample.txt", "section/.assets/subsample.txt"}
	for _, tc := range tcs {
		assertfile(t, tmp, tc)
	}
}

func readFile(path string) string {
	c, err := os.ReadFile(path)
	if err != nil {
		panic(fmt.Errorf("os.ReadFile: %w", err))
	}
	return string(c)
}

var anchor = regexp.MustCompile(`<a[^>]*>[^<]*</a>`)

func ExampleBuilder_tmplLinkReplacements() {
	_, dst := buildTestSite("testdata/link-replacements")
	fmt.Println(strings.Join(anchor.FindAllString(readFile(filepath.Join(dst, "a/tmpl.html")), -1), "\n"))
	// Output:
	// <a href="/a/b/#Title">subdir direct</a>
	// <a href="/a/b/#Title">subdir absolute</a>
	// <a href="/a/b/#Title">subdir redundancies</a>
	// <a href="/a/md.html#Title">sibling</a>
}

func ExampleBuilder_mdLinkReplacements() {
	_, dst := buildTestSite("testdata/link-replacements")
	fmt.Println(strings.Join(anchor.FindAllString(readFile(filepath.Join(dst, "a/md.html")), -1), "\n"))
	// Output:
	// <a href="/a/b/#Title">subdir direct</a>
	// <a href="/a/b/#Title">subdir absolute</a>
	// <a href="/a/b/#Title">subdir redundancies</a>
	// <a href="/a/tmpl.html#Title">sibling</a>
}

func dirSize(path string) (int64, error) {
	var size int64
	err := filepath.WalkDir(path, func(_ string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() {
			info, err := d.Info()
			if err != nil {
				return err
			}
			size += info.Size()
		}
		return nil
	})
	return size, err
}

// it duplicates the content folder root as a section
//
//	docs    docs
//	|-a     |-a
//	|-b  => |-b
//	        |-docs
//	          |-a
//	          |-b
func doubleUpContentFolder(path string) (float64, error) {
	copy.Dir(filepath.Join(path, "docs-again"), path)
	s, err := dirSize(path)
	if err != nil {
		return -1, fmt.Errorf("dirSize: %w", err)
	}
	return float64(s), nil
}

func toPythonArraySyntax(vs []float64) string {
	ss := []string{}
	for _, v := range vs {
		ss = append(ss, strconv.FormatFloat(v, 'f', 2, 64))
	}
	return fmt.Sprintf("[%s]", strings.Join(ss, ", "))
}

// TestBuilder_docsSite performs a series of builds with the docs site which
// its pages are de-duplicated 2*i times each run to check if the memory
// consumption scales sublinear.
func TestBuilder_docsSiteAllocationScaling(t *testing.T) {
	tmp := t.TempDir()
	fmt.Println(tmp)
	err := copy.Dir(tmp, "../../docs")
	if err != nil {
		t.Errorf("prep, copying docs site into the test directory to recursively duplicate its contents: %v", err)
	}
	f, a, err := scales.Allocations(20, func() (float64, error) {
		return doubleUpContentFolder(tmp)
	}, func() error {
		return Build(Args{Src: tmp, Dst: t.TempDir(), Domain: "/"})
	})
	if err != nil {
		t.Errorf("act, unexpected error: %v", err)
	} else if f == scales.NonSublinear {
		fmt.Printf("x=%s\n", toPythonArraySyntax(a.Sizes))
		fmt.Printf("y=%s\n", toPythonArraySyntax(a.Allocs))
		t.Fatal("assert memory allocation can't scale superlinear")
	}
}
