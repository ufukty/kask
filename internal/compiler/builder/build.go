package builder

import (
	"bytes"
	"fmt"
	"io"
	"net/url"
	"os"
	"path/filepath"
	"text/template"
	"time"

	"github.com/ufukty/kask/cmd/kask/commands/version"
	"github.com/ufukty/kask/internal/compiler/builder/bundler"
	"github.com/ufukty/kask/internal/compiler/builder/directory"
	"github.com/ufukty/kask/internal/compiler/builder/functions"
	"github.com/ufukty/kask/internal/compiler/builder/markdown"
)

var fileheader = fmt.Sprintf("<!-- Do not edit. Auto-generated by Kask %s -->", version.Version)

type UserSettings struct {
	Domain string
}

// to propagate *.tmpl and *.css files
type context struct {
	Template    *template.Template
	Stylesheets []string
	Page        string // inSitePath
}

func absolutify(prefix string, files []string) []string {
	files2 := []string{}
	for _, file := range files {
		files2 = append(files2, filepath.Join(prefix, file))
	}
	return files2
}

func build(dstroot string, uri string, root, d *directory.Dir, inherited *context, s *UserSettings) error {
	err := os.MkdirAll(filepath.Join(dstroot, d.InSitePath), 0755)
	if err != nil {
		return fmt.Errorf("os.MkdirAll: %w", err)
	}

	tmplPropagate, err := inherited.Template.Clone()
	if err != nil {
		return fmt.Errorf("inherited.Template.Clone: %w", err)
	}
	propagate := &context{
		Template:    tmplPropagate,
		Stylesheets: inherited.Stylesheets,
	}
	if d.Kask != nil && d.Kask.Propagate != nil {
		if len(d.Kask.Propagate.Css) > 0 {
			propcss, err := bundler.BundleCss(filepath.Join(dstroot, uri), "propagate", absolutify(filepath.Join(d.SiteRoot, d.InSitePath), d.Kask.Propagate.Css))
			if err != nil {
				return fmt.Errorf("bundler.BundleCss(.kask/propagate): %w", err)
			}
			url, err := url.JoinPath(s.Domain, d.InSitePath, propcss)
			if err != nil {
				return fmt.Errorf("url.JoinPath(.kask/propagate): %w", err)
			}
			propagate.Stylesheets = append(inherited.Stylesheets, url)
		}
		if len(d.Kask.Propagate.Tmpl) > 0 {
			_, err = propagate.Template.ParseFiles(absolutify(filepath.Join(d.SiteRoot, d.InSitePath), d.Kask.Propagate.Tmpl)...)
			if err != nil {
				return fmt.Errorf("propagate.Template.ParseFiles: %w", err)
			}
		}
	}

	tmplLevel, err := tmplPropagate.Clone()
	if err != nil {
		return fmt.Errorf("tmplPropagate.Clone: %w", err)
	}
	level := &context{
		Template:    tmplLevel,
		Stylesheets: propagate.Stylesheets,
	}
	if d.Kask != nil {
		if len(d.Kask.Css) > 0 {
			levelcss, err := bundler.BundleCss(filepath.Join(dstroot, uri), "styles", absolutify(filepath.Join(d.SiteRoot, d.InSitePath), d.Kask.Css))
			if err != nil {
				return fmt.Errorf("bundler.BundleCss(.kask): %w", err)
			}
			url, err := url.JoinPath(s.Domain, d.InSitePath, levelcss)
			if err != nil {
				return fmt.Errorf("url.JoinPath(.kask): %w", err)
			}
			level.Stylesheets = append(level.Stylesheets, url)
		}
		if len(d.Kask.Tmpl) > 0 {
			_, err = level.Template.ParseFiles(absolutify(filepath.Join(d.SiteRoot, d.InSitePath), d.Kask.Tmpl)...)
			if err != nil {
				return fmt.Errorf("level.Template.ParseFiles: %w", err)
			}
		}
	}

	dt := &Data{
		Stylesheets:     level.Stylesheets,
		WebSiteRoot:     root.Node,
		MarkdownContent: "",
		MarkdownTOC:     nil,
		Time:            time.Now(),
		Dir:             d,
	}

	queue := []*directory.Node{}
	if d.Node.Visitable {
		queue = append(queue, d.Node)
	}
	queue = append(queue, d.Node.Subpages...)

	for _, page := range queue {
		dt.Node = page
		tmplPage, err := tmplLevel.Clone()
		if err != nil {
			return fmt.Errorf("tmpLevel.Clone: %w", err)
		}
		buf := bytes.NewBuffer([]byte{})
		fmt.Fprintln(buf, fileheader)
		if page.PageType == directory.Html {
			tmplpath := filepath.Join(d.SiteRoot, d.InSitePath, page.SrcFilename)
			_, err = tmplPage.ParseFiles(tmplpath)
			if err != nil {
				return fmt.Errorf("tmplPage.ParseFiles: %w", err)
			}
			err = tmplPage.ExecuteTemplate(buf, "page", dt)
			if err != nil {
				return fmt.Errorf("tmplPage.ExecuteTemplate at %s: %w", tmplpath, err)
			}
		} else if page.PageType == directory.Md {
			_, err = tmplPage.ParseFiles(filepath.Join(d.SiteRoot, d.PageHtml)) // d.PageHtml contains InSitePath
			if err != nil {
				return fmt.Errorf("tmplPage.ParseFiles: %w", err)
			}
			html, toc, err := markdown.ToHtml(filepath.Join(d.SiteRoot, d.InSitePath, page.SrcFilename))
			if err != nil {
				return fmt.Errorf("markdown.ToHtml: %w", err)
			}
			dt.MarkdownContent = html
			dt.MarkdownTOC = toc
			err = tmplPage.ExecuteTemplate(buf, "page", dt)
			if err != nil {
				return fmt.Errorf("tmplLevel.ExecuteTemplate at %s: %w", filepath.Join(d.InSitePath, page.SrcFilename), err)
			}
		}
		dst, err := os.Create(filepath.Join(dstroot, page.TargetInSitePath))
		if err != nil {
			return fmt.Errorf("os.Create: %w", err)
		}
		defer dst.Close()
		_, err = io.Copy(dst, buf)
		if err != nil {
			return fmt.Errorf("io.Copy: %w", err)
		}
		dst.Close() // duplicate. because defer won't work until function returns
	}

	if d.Checks.HasAssetDir {
		err := copyDir(filepath.Join(dstroot, d.InSitePath, ".assets"), filepath.Join(d.SiteRoot, d.InSitePath, ".assets"))
		if err != nil {
			return fmt.Errorf("copyDir: %w", err)
		}
	}

	for _, sub := range d.Children {
		uri, err := url.JoinPath(uri, url.PathEscape(sub.Dirname))
		if err != nil {
			return fmt.Errorf("url.JoinPath: %w", err)
		}
		err = build(dstroot, uri, root, sub, propagate, s)
		if err != nil {
			return fmt.Errorf("build: %w", err)
		}
	}

	return nil
}

func Build(dst string, d *directory.Dir, s *UserSettings) error {
	t := template.New("root")
	t.Funcs(template.FuncMap{
		"breadcrumbs": functions.Breadcrumbs,
		"dict":        functions.Dict,
	})
	i := &context{
		Template:    t,
		Stylesheets: []string{},
	}
	err := build(dst, "/", d, d, i, s)
	if err != nil {
		return fmt.Errorf("build: %w", err)
	}
	return nil
}
